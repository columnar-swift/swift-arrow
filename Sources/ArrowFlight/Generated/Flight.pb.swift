// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Flight.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// <p>
// http://www.apache.org/licenses/LICENSE-2.0
// <p>
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// The result of a cancel operation.
///
/// This is used by CancelFlightInfoResult.status.
enum Arrow_Flight_Protocol_CancelStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// The cancellation status is unknown. Servers should avoid using
  /// this value (send a NOT_FOUND error if the requested query is
  /// not known). Clients can retry the request.
  case unspecified // = 0

  /// The cancellation request is complete. Subsequent requests with
  /// the same payload may return CANCELLED or a NOT_FOUND error.
  case cancelled // = 1

  /// The cancellation request is in progress. The client may retry
  /// the cancellation request.
  case cancelling // = 2

  /// The query is not cancellable. The client should not retry the
  /// cancellation request.
  case notCancellable // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .cancelled
    case 2: self = .cancelling
    case 3: self = .notCancellable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .cancelled: return 1
    case .cancelling: return 2
    case .notCancellable: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Arrow_Flight_Protocol_CancelStatus] = [
    .unspecified,
    .cancelled,
    .cancelling,
    .notCancellable,
  ]

}

///
/// The request that a client provides to a server on handshake.
struct Arrow_Flight_Protocol_HandshakeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A defined protocol version
  var protocolVersion: UInt64 = 0

  ///
  /// Arbitrary auth/handshake info.
  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arrow_Flight_Protocol_HandshakeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A defined protocol version
  var protocolVersion: UInt64 = 0

  ///
  /// Arbitrary auth/handshake info.
  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message for doing simple auth.
struct Arrow_Flight_Protocol_BasicAuth: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arrow_Flight_Protocol_Empty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Describes an available action, including both the name used for execution
/// along with a short description of the purpose of the action.
struct Arrow_Flight_Protocol_ActionType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A service specific expression that can be used to return a limited set
/// of available Arrow Flight streams.
struct Arrow_Flight_Protocol_Criteria: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expression: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// An opaque action specific for the service.
struct Arrow_Flight_Protocol_Action: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// An opaque result returned after executing an action.
struct Arrow_Flight_Protocol_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Wrap the result of a getSchema call
struct Arrow_Flight_Protocol_SchemaResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The schema of the dataset in its IPC form:
  ///   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
  ///   4 bytes - the byte length of the payload
  ///   a flatbuffer Message whose header is the Schema
  var schema: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// The name or tag for a Flight. May be used as a way to retrieve or generate
/// a flight or be used to expose a set of previously defined flights.
struct Arrow_Flight_Protocol_FlightDescriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Arrow_Flight_Protocol_FlightDescriptor.DescriptorType = .unknown

  ///
  /// Opaque value used to express a command. Should only be defined when
  /// type = CMD.
  var cmd: Data = Data()

  ///
  /// List of strings identifying a particular dataset. Should only be defined
  /// when type = PATH.
  var path: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Describes what type of descriptor is defined.
  enum DescriptorType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Protobuf pattern, not used.
    case unknown // = 0

    ///
    /// A named path that identifies a dataset. A path is composed of a string
    /// or list of strings describing a particular dataset. This is conceptually
    ///  similar to a path inside a filesystem.
    case path // = 1

    ///
    /// An opaque command to generate a dataset.
    case cmd // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .path
      case 2: self = .cmd
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .path: return 1
      case .cmd: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Arrow_Flight_Protocol_FlightDescriptor.DescriptorType] = [
      .unknown,
      .path,
      .cmd,
    ]

  }

  init() {}
}

///
/// The access coordinates for retrieval of a dataset. With a FlightInfo, a
/// consumer is able to determine how to retrieve a dataset.
struct Arrow_Flight_Protocol_FlightInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The schema of the dataset in its IPC form:
  ///   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
  ///   4 bytes - the byte length of the payload
  ///   a flatbuffer Message whose header is the Schema
  var schema: Data = Data()

  ///
  /// The descriptor associated with this info.
  var flightDescriptor: Arrow_Flight_Protocol_FlightDescriptor {
    get {return _flightDescriptor ?? Arrow_Flight_Protocol_FlightDescriptor()}
    set {_flightDescriptor = newValue}
  }
  /// Returns true if `flightDescriptor` has been explicitly set.
  var hasFlightDescriptor: Bool {return self._flightDescriptor != nil}
  /// Clears the value of `flightDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearFlightDescriptor() {self._flightDescriptor = nil}

  ///
  /// A list of endpoints associated with the flight. To consume the
  /// whole flight, all endpoints (and hence all Tickets) must be
  /// consumed. Endpoints can be consumed in any order.
  ///
  /// In other words, an application can use multiple endpoints to
  /// represent partitioned data.
  ///
  /// If the returned data has an ordering, an application can use
  /// "FlightInfo.ordered = true" or should return the all data in a
  /// single endpoint. Otherwise, there is no ordering defined on
  /// endpoints or the data within.
  ///
  /// A client can read ordered data by reading data from returned
  /// endpoints, in order, from front to back.
  ///
  /// Note that a client may ignore "FlightInfo.ordered = true". If an
  /// ordering is important for an application, an application must
  /// choose one of them:
  ///
  /// * An application requires that all clients must read data in
  ///   returned endpoints order.
  /// * An application must return the all data in a single endpoint.
  var endpoint: [Arrow_Flight_Protocol_FlightEndpoint] = []

  /// Set these to -1 if unknown.
  var totalRecords: Int64 = 0

  var totalBytes: Int64 = 0

  ///
  /// FlightEndpoints are in the same order as the data.
  var ordered: Bool = false

  ///
  /// Application-defined metadata.
  ///
  /// There is no inherent or required relationship between this
  /// and the app_metadata fields in the FlightEndpoints or resulting
  /// FlightData messages. Since this metadata is application-defined,
  /// a given application could define there to be a relationship,
  /// but there is none required by the spec.
  var appMetadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _flightDescriptor: Arrow_Flight_Protocol_FlightDescriptor? = nil
}

///
/// The information to process a long-running query.
struct Arrow_Flight_Protocol_PollInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The currently available results.
  ///
  /// If "flight_descriptor" is not specified, the query is complete
  /// and "info" specifies all results. Otherwise, "info" contains
  /// partial query results.
  ///
  /// Note that each PollInfo response contains a complete
  /// FlightInfo (not just the delta between the previous and current
  /// FlightInfo).
  ///
  /// Subsequent PollInfo responses may only append new endpoints to
  /// info.
  ///
  /// Clients can begin fetching results via DoGet(Ticket) with the
  /// ticket in the info before the query is
  /// completed. FlightInfo.ordered is also valid.
  var info: Arrow_Flight_Protocol_FlightInfo {
    get {return _info ?? Arrow_Flight_Protocol_FlightInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  ///
  /// The descriptor the client should use on the next try.
  /// If unset, the query is complete.
  var flightDescriptor: Arrow_Flight_Protocol_FlightDescriptor {
    get {return _flightDescriptor ?? Arrow_Flight_Protocol_FlightDescriptor()}
    set {_flightDescriptor = newValue}
  }
  /// Returns true if `flightDescriptor` has been explicitly set.
  var hasFlightDescriptor: Bool {return self._flightDescriptor != nil}
  /// Clears the value of `flightDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearFlightDescriptor() {self._flightDescriptor = nil}

  ///
  /// Query progress. If known, must be in [0.0, 1.0] but need not be
  /// monotonic or nondecreasing. If unknown, do not set.
  var progress: Double {
    get {return _progress ?? 0}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  mutating func clearProgress() {self._progress = nil}

  ///
  /// Expiration time for this request. After this passes, the server
  /// might not accept the retry descriptor anymore (and the query may
  /// be cancelled). This may be updated on a call to PollFlightInfo.
  var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTime() {self._expirationTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Arrow_Flight_Protocol_FlightInfo? = nil
  fileprivate var _flightDescriptor: Arrow_Flight_Protocol_FlightDescriptor? = nil
  fileprivate var _progress: Double? = nil
  fileprivate var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///
/// The request of the CancelFlightInfo action.
///
/// The request should be stored in Action.body.
struct Arrow_Flight_Protocol_CancelFlightInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Arrow_Flight_Protocol_FlightInfo {
    get {return _info ?? Arrow_Flight_Protocol_FlightInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Arrow_Flight_Protocol_FlightInfo? = nil
}

///
/// The result of the CancelFlightInfo action.
///
/// The result should be stored in Result.body.
struct Arrow_Flight_Protocol_CancelFlightInfoResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Arrow_Flight_Protocol_CancelStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// An opaque identifier that the service can use to retrieve a particular
/// portion of a stream.
///
/// Tickets are meant to be single use. It is an error/application-defined
/// behavior to reuse a ticket.
struct Arrow_Flight_Protocol_Ticket: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ticket: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A location to retrieve a particular stream from. This URI should be one of
/// the following:
///  - An empty string or the string 'arrow-flight-reuse-connection://?':
///    indicating that the ticket can be redeemed on the service where the
///    ticket was generated via a DoGet request.
///  - A valid grpc URI (grpc://, grpc+tls://, grpc+unix://, etc.):
///    indicating that the ticket can be redeemed on the service at the given
///    URI via a DoGet request.
///  - A valid HTTP URI (http://, https://, etc.):
///    indicating that the client should perform a GET request against the
///    given URI to retrieve the stream. The ticket should be empty
///    in this case and should be ignored by the client. Cloud object storage
///    can be utilized by presigned URLs or mediating the auth separately and
///    returning the full URL (e.g. https://amzn-s3-demo-bucket.s3.us-west-2.amazonaws.com/...).
///
/// We allow non-Flight URIs for the purpose of allowing Flight services to indicate that
/// results can be downloaded in formats other than Arrow (such as Parquet) or to allow
/// direct fetching of results from a URI to reduce excess copying and data movement.
/// In these cases, the following conventions should be followed by servers and clients:
///
///  - Unless otherwise specified by the 'Content-Type' header of the response,
///    a client should assume the response is using the Arrow IPC Streaming format.
///    Usage of an IANA media type like 'application/octet-stream' should be assumed to
///    be using the Arrow IPC Streaming format.
///  - The server may allow the client to choose a specific response format by
///    specifying an 'Accept' header in the request, such as 'application/vnd.apache.parquet'
///    or 'application/vnd.apache.arrow.stream'. If multiple types are requested and
///    supported by the server, the choice of which to use is server-specific. If
///    none of the requested content-types are supported, the server may respond with
///    either 406 (Not Acceptable) or 415 (Unsupported Media Type), or successfully
///    respond with a different format that it does support along with the correct
///    'Content-Type' header.
///
/// Note: new schemes may be proposed in the future to allow for more flexibility based
/// on community requests.
struct Arrow_Flight_Protocol_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A particular stream or split associated with a flight.
struct Arrow_Flight_Protocol_FlightEndpoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Token used to retrieve this stream.
  var ticket: Arrow_Flight_Protocol_Ticket {
    get {return _ticket ?? Arrow_Flight_Protocol_Ticket()}
    set {_ticket = newValue}
  }
  /// Returns true if `ticket` has been explicitly set.
  var hasTicket: Bool {return self._ticket != nil}
  /// Clears the value of `ticket`. Subsequent reads from it will return its default value.
  mutating func clearTicket() {self._ticket = nil}

  ///
  /// A list of URIs where this ticket can be redeemed via DoGet().
  ///
  /// If the list is empty, the expectation is that the ticket can only
  /// be redeemed on the current service where the ticket was
  /// generated.
  ///
  /// If the list is not empty, the expectation is that the ticket can be
  /// redeemed at any of the locations, and that the data returned will be
  /// equivalent. In this case, the ticket may only be redeemed at one of the
  /// given locations, and not (necessarily) on the current service. If one
  /// of the given locations is "arrow-flight-reuse-connection://?", the
  /// client may redeem the ticket on the service where the ticket was
  /// generated (i.e., the same as above), in addition to the other
  /// locations. (This URI was chosen to maximize compatibility, as 'scheme:'
  /// or 'scheme://' are not accepted by Java's java.net.URI.)
  ///
  /// In other words, an application can use multiple locations to
  /// represent redundant and/or load balanced services.
  var location: [Arrow_Flight_Protocol_Location] = []

  ///
  /// Expiration time of this stream. If present, clients may assume
  /// they can retry DoGet requests. Otherwise, it is
  /// application-defined whether DoGet requests may be retried.
  var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTime() {self._expirationTime = nil}

  ///
  /// Application-defined metadata.
  ///
  /// There is no inherent or required relationship between this
  /// and the app_metadata fields in the FlightInfo or resulting
  /// FlightData messages. Since this metadata is application-defined,
  /// a given application could define there to be a relationship,
  /// but there is none required by the spec.
  var appMetadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ticket: Arrow_Flight_Protocol_Ticket? = nil
  fileprivate var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///
/// The request of the RenewFlightEndpoint action.
///
/// The request should be stored in Action.body.
struct Arrow_Flight_Protocol_RenewFlightEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var endpoint: Arrow_Flight_Protocol_FlightEndpoint {
    get {return _endpoint ?? Arrow_Flight_Protocol_FlightEndpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  mutating func clearEndpoint() {self._endpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _endpoint: Arrow_Flight_Protocol_FlightEndpoint? = nil
}

///
/// A batch of Arrow data as part of a stream of batches.
struct Arrow_Flight_Protocol_FlightData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The descriptor of the data. This is only relevant when a client is
  /// starting a new DoPut stream.
  var flightDescriptor: Arrow_Flight_Protocol_FlightDescriptor {
    get {return _flightDescriptor ?? Arrow_Flight_Protocol_FlightDescriptor()}
    set {_flightDescriptor = newValue}
  }
  /// Returns true if `flightDescriptor` has been explicitly set.
  var hasFlightDescriptor: Bool {return self._flightDescriptor != nil}
  /// Clears the value of `flightDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearFlightDescriptor() {self._flightDescriptor = nil}

  ///
  /// Header for message data as described in Message.fbs::Message.
  var dataHeader: Data = Data()

  ///
  /// Application-defined metadata.
  var appMetadata: Data = Data()

  ///
  /// The actual batch of Arrow data. Preferably handled with minimal-copies
  /// coming last in the definition to help with sidecar patterns (it is
  /// expected that some implementations will fetch this field off the wire
  /// with specialized code to avoid extra memory copies).
  var dataBody: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _flightDescriptor: Arrow_Flight_Protocol_FlightDescriptor? = nil
}

///*
/// The response message associated with the submission of a DoPut.
struct Arrow_Flight_Protocol_PutResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appMetadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// EXPERIMENTAL: Union of possible value types for a Session Option to be set to.
///
/// By convention, an attempt to set a valueless SessionOptionValue should
/// attempt to unset or clear the named option value on the server.
struct Arrow_Flight_Protocol_SessionOptionValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionValue: Arrow_Flight_Protocol_SessionOptionValue.OneOf_OptionValue? = nil

  var stringValue: String {
    get {
      if case .stringValue(let v)? = optionValue {return v}
      return String()
    }
    set {optionValue = .stringValue(newValue)}
  }

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = optionValue {return v}
      return false
    }
    set {optionValue = .boolValue(newValue)}
  }

  var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = optionValue {return v}
      return 0
    }
    set {optionValue = .int64Value(newValue)}
  }

  var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = optionValue {return v}
      return 0
    }
    set {optionValue = .doubleValue(newValue)}
  }

  var stringListValue: Arrow_Flight_Protocol_SessionOptionValue.StringListValue {
    get {
      if case .stringListValue(let v)? = optionValue {return v}
      return Arrow_Flight_Protocol_SessionOptionValue.StringListValue()
    }
    set {optionValue = .stringListValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionValue: Equatable, Sendable {
    case stringValue(String)
    case boolValue(Bool)
    case int64Value(Int64)
    case doubleValue(Double)
    case stringListValue(Arrow_Flight_Protocol_SessionOptionValue.StringListValue)

  }

  struct StringListValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var values: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///
/// EXPERIMENTAL: A request to set session options for an existing or new (implicit)
/// server session.
///
/// Sessions are persisted and referenced via a transport-level state management, typically
/// RFC 6265 HTTP cookies when using an HTTP transport.  The suggested cookie name or state
/// context key is 'arrow_flight_session_id', although implementations may freely choose their
/// own name.
///
/// Session creation (if one does not already exist) is implied by this RPC request, however
/// server implementations may choose to initiate a session that also contains client-provided
/// session options at any other time, e.g. on authentication, or when any other call is made
/// and the server wishes to use a session to persist any state (or lack thereof).
struct Arrow_Flight_Protocol_SetSessionOptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionOptions: Dictionary<String,Arrow_Flight_Protocol_SessionOptionValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// EXPERIMENTAL: The results (individually) of setting a set of session options.
///
/// Option names should only be present in the response if they were not successfully
/// set on the server; that is, a response without an Error for a name provided in the
/// SetSessionOptionsRequest implies that the named option value was set successfully.
struct Arrow_Flight_Protocol_SetSessionOptionsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errors: Dictionary<String,Arrow_Flight_Protocol_SetSessionOptionsResult.Error> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ErrorValue: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Protobuf deserialization fallback value: The status is unknown or unrecognized.
    /// Servers should avoid using this value. The request may be retried by the client.
    case unspecified // = 0

    /// The given session option name is invalid.
    case invalidName // = 1

    /// The session option value or type is invalid.
    case invalidValue // = 2

    /// The session option cannot be set.
    case error // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .invalidName
      case 2: self = .invalidValue
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .invalidName: return 1
      case .invalidValue: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Arrow_Flight_Protocol_SetSessionOptionsResult.ErrorValue] = [
      .unspecified,
      .invalidName,
      .invalidValue,
      .error,
    ]

  }

  struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Arrow_Flight_Protocol_SetSessionOptionsResult.ErrorValue = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///
/// EXPERIMENTAL: A request to access the session options for the current server session.
///
/// The existing session is referenced via a cookie header or similar (see
/// SetSessionOptionsRequest above); it is an error to make this request with a missing,
/// invalid, or expired session cookie header or other implementation-defined session
/// reference token.
struct Arrow_Flight_Protocol_GetSessionOptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// EXPERIMENTAL: The result containing the current server session options.
struct Arrow_Flight_Protocol_GetSessionOptionsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionOptions: Dictionary<String,Arrow_Flight_Protocol_SessionOptionValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Request message for the "Close Session" action.
///
/// The exiting session is referenced via a cookie header.
struct Arrow_Flight_Protocol_CloseSessionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// The result of closing a session.
struct Arrow_Flight_Protocol_CloseSessionResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Arrow_Flight_Protocol_CloseSessionResult.Status = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Protobuf deserialization fallback value: The session close status is unknown or
    /// not recognized. Servers should avoid using this value (send a NOT_FOUND error if
    /// the requested session is not known or expired). Clients can retry the request.
    case unspecified // = 0

    /// The session close request is complete. Subsequent requests with
    /// the same session produce a NOT_FOUND error.
    case closed // = 1

    /// The session close request is in progress. The client may retry
    /// the close request.
    case closing // = 2

    /// The session is not closeable. The client should not retry the
    /// close request.
    case notCloseable // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .closed
      case 2: self = .closing
      case 3: self = .notCloseable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .closed: return 1
      case .closing: return 2
      case .notCloseable: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Arrow_Flight_Protocol_CloseSessionResult.Status] = [
      .unspecified,
      .closed,
      .closing,
      .notCloseable,
    ]

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arrow.flight.protocol"

extension Arrow_Flight_Protocol_CancelStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CANCEL_STATUS_UNSPECIFIED\0\u{1}CANCEL_STATUS_CANCELLED\0\u{1}CANCEL_STATUS_CANCELLING\0\u{1}CANCEL_STATUS_NOT_CANCELLABLE\0")
}

extension Arrow_Flight_Protocol_HandshakeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HandshakeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}protocol_version\0\u{1}payload\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protocolVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.protocolVersion, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_HandshakeRequest, rhs: Arrow_Flight_Protocol_HandshakeRequest) -> Bool {
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_HandshakeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HandshakeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}protocol_version\0\u{1}payload\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protocolVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.protocolVersion, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_HandshakeResponse, rhs: Arrow_Flight_Protocol_HandshakeResponse) -> Bool {
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_BasicAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasicAuth"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}username\0\u{1}password\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_BasicAuth, rhs: Arrow_Flight_Protocol_BasicAuth) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_Empty, rhs: Arrow_Flight_Protocol_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_ActionType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}description\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_ActionType, rhs: Arrow_Flight_Protocol_ActionType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_Criteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Criteria"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}expression\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.expression) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expression.isEmpty {
      try visitor.visitSingularBytesField(value: self.expression, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_Criteria, rhs: Arrow_Flight_Protocol_Criteria) -> Bool {
    if lhs.expression != rhs.expression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Action"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}body\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_Action, rhs: Arrow_Flight_Protocol_Action) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Result"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}body\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_Result, rhs: Arrow_Flight_Protocol_Result) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_SchemaResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SchemaResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schema\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.schema) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schema.isEmpty {
      try visitor.visitSingularBytesField(value: self.schema, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_SchemaResult, rhs: Arrow_Flight_Protocol_SchemaResult) -> Bool {
    if lhs.schema != rhs.schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_FlightDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlightDescriptor"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}cmd\0\u{1}path\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cmd) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.cmd.isEmpty {
      try visitor.visitSingularBytesField(value: self.cmd, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_FlightDescriptor, rhs: Arrow_Flight_Protocol_FlightDescriptor) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.cmd != rhs.cmd {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_FlightDescriptor.DescriptorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}PATH\0\u{1}CMD\0")
}

extension Arrow_Flight_Protocol_FlightInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlightInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schema\0\u{3}flight_descriptor\0\u{1}endpoint\0\u{3}total_records\0\u{3}total_bytes\0\u{1}ordered\0\u{3}app_metadata\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.schema) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._flightDescriptor) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.endpoint) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalRecords) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalBytes) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ordered) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.appMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schema.isEmpty {
      try visitor.visitSingularBytesField(value: self.schema, fieldNumber: 1)
    }
    try { if let v = self._flightDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.endpoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoint, fieldNumber: 3)
    }
    if self.totalRecords != 0 {
      try visitor.visitSingularInt64Field(value: self.totalRecords, fieldNumber: 4)
    }
    if self.totalBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBytes, fieldNumber: 5)
    }
    if self.ordered != false {
      try visitor.visitSingularBoolField(value: self.ordered, fieldNumber: 6)
    }
    if !self.appMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.appMetadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_FlightInfo, rhs: Arrow_Flight_Protocol_FlightInfo) -> Bool {
    if lhs.schema != rhs.schema {return false}
    if lhs._flightDescriptor != rhs._flightDescriptor {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.totalRecords != rhs.totalRecords {return false}
    if lhs.totalBytes != rhs.totalBytes {return false}
    if lhs.ordered != rhs.ordered {return false}
    if lhs.appMetadata != rhs.appMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_PollInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{3}flight_descriptor\0\u{1}progress\0\u{3}expiration_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._flightDescriptor) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._progress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expirationTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._flightDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._progress {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_PollInfo, rhs: Arrow_Flight_Protocol_PollInfo) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._flightDescriptor != rhs._flightDescriptor {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_CancelFlightInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelFlightInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_CancelFlightInfoRequest, rhs: Arrow_Flight_Protocol_CancelFlightInfoRequest) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_CancelFlightInfoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelFlightInfoResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_CancelFlightInfoResult, rhs: Arrow_Flight_Protocol_CancelFlightInfoResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_Ticket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ticket"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ticket\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ticket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticket.isEmpty {
      try visitor.visitSingularBytesField(value: self.ticket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_Ticket, rhs: Arrow_Flight_Protocol_Ticket) -> Bool {
    if lhs.ticket != rhs.ticket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uri\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_Location, rhs: Arrow_Flight_Protocol_Location) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_FlightEndpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlightEndpoint"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ticket\0\u{1}location\0\u{3}expiration_time\0\u{3}app_metadata\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ticket) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expirationTime) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.appMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ticket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.location.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.location, fieldNumber: 2)
    }
    try { if let v = self._expirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.appMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.appMetadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_FlightEndpoint, rhs: Arrow_Flight_Protocol_FlightEndpoint) -> Bool {
    if lhs._ticket != rhs._ticket {return false}
    if lhs.location != rhs.location {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.appMetadata != rhs.appMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_RenewFlightEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RenewFlightEndpointRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_RenewFlightEndpointRequest, rhs: Arrow_Flight_Protocol_RenewFlightEndpointRequest) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_FlightData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlightData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}flight_descriptor\0\u{3}data_header\0\u{3}app_metadata\0\u{4}e\u{f}data_body\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._flightDescriptor) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.dataHeader) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.appMetadata) }()
      case 1000: try { try decoder.decodeSingularBytesField(value: &self.dataBody) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flightDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dataHeader.isEmpty {
      try visitor.visitSingularBytesField(value: self.dataHeader, fieldNumber: 2)
    }
    if !self.appMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.appMetadata, fieldNumber: 3)
    }
    if !self.dataBody.isEmpty {
      try visitor.visitSingularBytesField(value: self.dataBody, fieldNumber: 1000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_FlightData, rhs: Arrow_Flight_Protocol_FlightData) -> Bool {
    if lhs._flightDescriptor != rhs._flightDescriptor {return false}
    if lhs.dataHeader != rhs.dataHeader {return false}
    if lhs.appMetadata != rhs.appMetadata {return false}
    if lhs.dataBody != rhs.dataBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_PutResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PutResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}app_metadata\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.appMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.appMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_PutResult, rhs: Arrow_Flight_Protocol_PutResult) -> Bool {
    if lhs.appMetadata != rhs.appMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_SessionOptionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionOptionValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}string_value\0\u{3}bool_value\0\u{3}int64_value\0\u{3}double_value\0\u{3}string_list_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionValue != nil {try decoder.handleConflictingOneOf()}
          self.optionValue = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionValue != nil {try decoder.handleConflictingOneOf()}
          self.optionValue = .boolValue(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularSFixed64Field(value: &v)
        if let v = v {
          if self.optionValue != nil {try decoder.handleConflictingOneOf()}
          self.optionValue = .int64Value(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.optionValue != nil {try decoder.handleConflictingOneOf()}
          self.optionValue = .doubleValue(v)
        }
      }()
      case 5: try {
        var v: Arrow_Flight_Protocol_SessionOptionValue.StringListValue?
        var hadOneofValue = false
        if let current = self.optionValue {
          hadOneofValue = true
          if case .stringListValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.optionValue = .stringListValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.optionValue {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.optionValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.optionValue else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .int64Value?: try {
      guard case .int64Value(let v)? = self.optionValue else { preconditionFailure() }
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 3)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.optionValue else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case .stringListValue?: try {
      guard case .stringListValue(let v)? = self.optionValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_SessionOptionValue, rhs: Arrow_Flight_Protocol_SessionOptionValue) -> Bool {
    if lhs.optionValue != rhs.optionValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_SessionOptionValue.StringListValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arrow_Flight_Protocol_SessionOptionValue.protoMessageName + ".StringListValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_SessionOptionValue.StringListValue, rhs: Arrow_Flight_Protocol_SessionOptionValue.StringListValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_SetSessionOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSessionOptionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_options\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arrow_Flight_Protocol_SessionOptionValue>.self, value: &self.sessionOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionOptions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arrow_Flight_Protocol_SessionOptionValue>.self, value: self.sessionOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_SetSessionOptionsRequest, rhs: Arrow_Flight_Protocol_SetSessionOptionsRequest) -> Bool {
    if lhs.sessionOptions != rhs.sessionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_SetSessionOptionsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSessionOptionsResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}errors\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arrow_Flight_Protocol_SetSessionOptionsResult.Error>.self, value: &self.errors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arrow_Flight_Protocol_SetSessionOptionsResult.Error>.self, value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_SetSessionOptionsResult, rhs: Arrow_Flight_Protocol_SetSessionOptionsResult) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_SetSessionOptionsResult.ErrorValue: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}INVALID_NAME\0\u{1}INVALID_VALUE\0\u{1}ERROR\0")
}

extension Arrow_Flight_Protocol_SetSessionOptionsResult.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arrow_Flight_Protocol_SetSessionOptionsResult.protoMessageName + ".Error"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .unspecified {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_SetSessionOptionsResult.Error, rhs: Arrow_Flight_Protocol_SetSessionOptionsResult.Error) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_GetSessionOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionOptionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_GetSessionOptionsRequest, rhs: Arrow_Flight_Protocol_GetSessionOptionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_GetSessionOptionsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionOptionsResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_options\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arrow_Flight_Protocol_SessionOptionValue>.self, value: &self.sessionOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionOptions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arrow_Flight_Protocol_SessionOptionValue>.self, value: self.sessionOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_GetSessionOptionsResult, rhs: Arrow_Flight_Protocol_GetSessionOptionsResult) -> Bool {
    if lhs.sessionOptions != rhs.sessionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_CloseSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseSessionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_CloseSessionRequest, rhs: Arrow_Flight_Protocol_CloseSessionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_CloseSessionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseSessionResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arrow_Flight_Protocol_CloseSessionResult, rhs: Arrow_Flight_Protocol_CloseSessionResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arrow_Flight_Protocol_CloseSessionResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}CLOSED\0\u{1}CLOSING\0\u{1}NOT_CLOSEABLE\0")
}
